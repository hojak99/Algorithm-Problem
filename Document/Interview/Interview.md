# Coding Interview

1. 객체지향 프로그램이란?
> 캡슐화, 다형성, 상속을 이용해 코드 재사용성을 늘리고, 유지보수를 감소시키기 위해 객체들을 연결시켜 프로그래밍 하는 것.
  
2. 캡슐화
> - 데이터(변수) 및 함수(메소드)를 논리적으로 하나로 묶은 것(Class)
> - 데이터데이터 일부를 감춰서 외부와의 접근을 메소드(getter, setter)를 통해서만 가능하도록 하는 것

3. 상속
> - 자식클래스에서 부모클래스의 코드를 재사용하기 위함
> - 연관된 일련의 클래스의 공통된 규약을 정의하고 적용하기 위함

4. 다형성
> - Overriding : 부모클래스를 상속받은 자식클래스에서 부모클래스의 메소드를 같은 이름, 같은 매개변수, 같은 반환 값으로 재정의 하는 것
> - Overroding : 하나의 클래에 같은 이름, 다른 매개변수, 반환 값은 상관없이 재정의 하는 것

5. 생성자
> - 인스턴스를 생성할 때마다 호출되는 인스턴스 초기화 메소드
> - return 값이 없음
> - 클래스 이름과 같아야 함
> - 기본 생성자가 아닌 생성자 메소드를 정의하면 무조건 기본 생성자를 만들어줘야 함

6. 가비지 컬렉터 (Garbage Collector)
> - 더 이상 사용하지 않는 객체들을 자동으로 청소(메모리 해제)시켜줌
> - 객체를 생성하면 Heap 내에 Young 영역으로 가서 이곳에서 접근 불가능 상태가 되서 객체가 사라질 때(메모리 해제)를 "Minor GC 가 발생했다" 라고 한고, 여기서 살아남은 객체들이 Old 영역으로 가서 이곳에서 접근 불가능한 상태가 되서 객체가 사라질 때(메모리 해제)를 "Major GC 가 발생했다" 라고 한다.

7. Java primitive data types 
> byte, short, int, long, double, float, boolean, char

8. 컴파일러와 인터프리터
> - Compiler : 프로그램 단위로 프로그램 전체를 함께 번역하고 수행하기 때문에 번역 시간은 오래 걸리지만 수행 속도는 빠름
> - Interpreter : 한 줄, 한 줄씩 번역해 수행하기 때문에 수행속도는 느리다. 이로 인해 CPU 사용 시간이 낭비된다고 한다.

9. 자바 실행과정
> .java 를 byte code(.class)로 변환하여 JVM 으로 실행  
> 즉, .java 를 컴파일 한 후 그 결과로 나온 .class 파일들을 JVM 으로 한 줄, 한 줄씩 읽는다

10. JVM 메모리 구조 (Runtime Data Area)
> - Method Area : 인스턴스 생성을 위한 필요 정보(필드, 메소드, 생성자)를 적재한 공간
> - Heap : 객체들이 적재되는 공간. 메소드 지역에서 참조한 값을 바탕으로 새로운 객체를 생성하면 이곳에 적재한다. 또한, 모든 스레드는 하나의 Heap 을 공유한다.
> - Stack : 메소드 프레임들이 스택에 하나씩 쌓임. Last in First out 이다. 또한, 스레드는 자신들만의 고유한 Stack을 가지고 있다.
> - PC Register : 현재 실행되고 있는 부분의 주소를 가지고 있다. 프로그램 카운트는 현재 실행되고 있는 명령이 끝나고 증가된다.
> - Native Method Area : 네이티브 방식의 메소드가 실행될 경우 이곳에 적재된다.

11. OSI 7계층 - 물데네전세표응~
> - 물리계층 : 하드웨어의 물리적이고 전자적인 특성을 정의. 디지털 신호를 전기신호로 변환해 전송한다.
> - 데이터 링크 계층 : 물리 계층의 연결 신뢰도 향상. 링크의 활성화, 유지, 비활성화 기능 제공
> - 네트워크 계층 : 패킷 단위로 데이터를 분할. 경로 설정.
> - 전송 계층 : 경로 설정 및 데이터 전송 책임. 세션 계층에 서비스 제공. 노드와 노드 사이 라우팅 지시
> - 세션 계층 : 연결 공유, 전송 조정, 데이터 동기화, 네트워크 오류 검사, 데이터 재전송
> - 표현 계층 : 문자집합 변환. 캡슐화, 압축
> - 응용 계층 : 사용자 프로그램과 관련된 계층. 응용 프로그램을 네트워크와 연결

12. TCP / UDP
> - TCP : 연결지향으로, 자체적으로 오류해결. 네트웍 전송 중 뒤바뀐 메세지를 교정해주는 기능있음.  
실시간 처리 시 메세지 순서 잘못되면 다시 요청
> - UDP : 비연결지향, 오류처리나 순서 재조합 기능 없음. 단순히 데이터를 받거나 던지기만 함  
실시간 처리시 패킷 손실 있어도 그냥 처리함

13. HTTP / HTTPS
> - HTTP : TCP/IP 를 이용하는 응용 프로토콜. 연결 상태를 유지하지 않는 프로토콜임. 그래서 요청과 응답이 존재하며, 암호화 X, 통신 상태 확인 X -> 변조 가능
> - HTTPS : HTTP 통신을 하는 부분을 SSL or TLS 로 대체. (TCP 와 통신하지 않고 SSL 통신). 하지만 느린데 이 이유는 클라이언트 요청 시, SSL에 필요한 통신 추가와 암호화, 복호화 계산으로 인해 리소스 낭비하기 때문.
> - 추가적으로 웹 관련으로 면접볼거면 SSL, TLS 정도는 알고가자 ㅎㅎ

14. Web Application Server (WAS)
> - WAS : 웹 서버와 웹 컨테이너의 결합으로 다양한 기능을 컨테이너에 구현하여 다양한 역할을 수행할 수 있는 서버, 서버 단에서 어플ㄹ케이션을 동작할 수 있도록 지원하는 서버(동적인 컨텐츠 제공)
> - Web Container : JSP, Servlet 구동 환경 제공 (동적 data 처리)
> - Web Server : 요청 받아 Controller 로 전송 / 결과값 받아 클라이언트로 전송 (동적 data 처리)
> - Ex : '개발자' 라고 검색할 시 DB 에서 가져오고 하는 일은 WAS, 검색 후 보여지는 웹 브라우저의 HTML, CSS, JS 등은 웹 서버에서 처리

15. 스프링 동작 과정
> - 클라이언트 요청 시(URL) 디스패처 서블릿으로.
> - 디스패처 서블릿에서 Handler Mapping 에 요청 URL 과 매핑되는 컨트롤러 검색
> - 매핑된 컨트롤러로 처리요청 후 Model, View 반환
> - 디스패처 서블릿에서 View Resolver 로 반환받은 view 정보를 넘겨 view 검색
> - View Resolver 에서 view 리턴
> - 디스패처 서블릿에서 View 로 리턴받은 view 와, Model 을 넘겨 Model 에 데이터를 view에 셋팅 후 디스패처 서블릿으로 반환
> - 디스패처 서블릿에서 클라이언트로 반환

16. AOP (Aspect Oriented Programming)
> - 기능을 핵심 비지니스 로직과 공통 모듈로 구분하고, 핵심 로직에 영향을 미치지 않고 사이사이에 공통 모듈을 효과적으로 잘 끼워넣도록 하는 방법
> - EX) 보안 인증, 세션, 로깅 같은 요소

17. IoC / DI
> - IoC : 작업을 수행하는 쪽에서 객체를 생성하는게 아닌 특별한 object 에 의해 만들어지고 사용된다. EX) 프레임워크
> - DI : 각 계층 사이, 각 클래스 사이에 필요로 하는 의존관계를 컨테이너가 자동으로 연결 해주는 것
> - DL : Bean 에 접근하기 위해 컨테이너에서 제공하는 API를 이용해 LookUp 하는 것

18. API 
> - 기존의 어떤 프로그램을 제어할 수 있도록 만든 인터페이스

19. REST
> - URI 와 HTTP 메소드를 이용해 객체화된 서비스에 접근하는 것.
> - 리소스에 접근하여 HTTP 메소드를 이용한 그것을 조작하는 것
> - RESTful API : 리소스 행위 직관적 분리, 메세지는 헤더와 바디를 명확하게 분리, 서버와 클라가 같은 방식으로 요청하도록 해야 함

20. equals 와 == 차이
> - equals 는 객체의 값으로 비교를 함 (메소드)
> - == 은 객체의 주소값으로 비교 (연산자)

21. String a="" 과 new String("") 의 차이
> -  a = "" 같은 경우 Heap 내의 String constant pool 에 저장시키거나 이미 존재하는 문자열이면 그 저장된 배열의 인덱스 번호를 가리키게 한다. 
> - new String("") 는 Heap 내의 일반적인 객체를 생성한다.
<pre><code>
String a = "a";
String b = "a";
a == b 는 true

String a = new String("a");
String b = new String("a");
a == b 는 false
</code></pre>

22. GET, POST
> - GET : 요청하는 데이터가 HTTP Request Message Header 부분의 url 에 담겨 전송. 그래서 데이터 크기에 제한. url 에 노출됨  
서버에서 데이터 가져올 때
> - POST : 요청하는 데이터가 HTTP Request Body 에 함께 전송. GET 보다 데이터 크기 크게 보내기 가능  
서버 값이나 상태 변경할 때

23. 프로세스와 스레드 차이
> - 프로세스 : 실행 중인 프로그램 (램에 올라간 프로그램). 메모리에 주소 공간을 갖는다.
> - 스레드 : 프로세스의 실행 단위. 한 프로세스 내에서 동작하는 여러 실행흐름으로, 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. 

24. Hash Map 작동 원리
> - Hash Map : key 와 Value 로 이루어진 자료구조. 내부구조는 배열로 되어있음
> - 인덱스를 구하기 위해 해쉬함수를 사용함. 그래서 Hash Code 를 구하면 동일 중복 값이 발생할 수 있는데(해쉬 충돌) 해쉬 충돌을 방지하기 위해 <code>Open Adressing</code> 과 <code>Separate Chaning</code> 이 있다.
> - Open Adressing : 해쉬충돌 발생 시 인접 index 값을 새로 구해서 해쉬충돌 우회
> - Separate Chaning : 동일한 해쉬 값 존재 시 링크드리스트로 관리
> - Java 8 에서는 데이터가 6개 이상이면 Tree 를 사용하고 6개 이하면 링크드리스트를 사용한다.
> - 여기서 2개의 차이를 둔 것은 만약 차이가 1일 때 어떤 한 데이터가 반복되어 삽입 삭제 되는 경우 트리와 링크드리스트를 변경하는데 반복되므로 성능 저하가 발생되므로 2개의 차이를 둠

25. 세션과 쿠키
> - Session : 일정 시간동안 같은 사용자(브라우저)로 부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술
> - Cookie : 특정 웹 사이트를 방문했을 때 만들어지는 정보를 담는 파일

여기서 쿠키는 컴퓨터 메모리에 저장하지만, 세션은 웹서버에 저장된다.

HTTP Session 의 동작 순서는 다음과 같다.
1. 클라이언트가 서버로 request 날린다.
2. 서버는 클라이언트가 보낸 request header 에 cookie 를 확인해 session-id 존재하는지 확인
3. 없으면 session-id 생성해 response 헤더에 담아 보낸다
