# Coding Interview

## 1. 객체지향 프로그램이란?
> 캡슐화, 다형성, 상속을 이용해 코드 재사용성을 늘리고, 유지보수를 감소시키기 위해 객체들을 연결시켜 프로그래밍 하는 것.

---  

## 2. 캡슐화
> - 데이터(변수) 및 함수(메소드)를 논리적으로 하나로 묶은 것(Class)
> - 데이터 일부를 감춰서 외부와의 접근을 메소드(getter, setter)를 통해서만 가능하도록 하는 것

---  

## 3. 상속
> - 자식클래스에서 부모클래스의 코드를 재사용하기 위함
> - 연관된 일련의 클래스의 공통된 규약을 정의하고 적용하기 위함

---  

## 4. 다형성
> - Overriding : 부모클래스를 상속받은 자식클래스에서 부모클래스의 메소드를 같은 이름, 같은 매개변수, 같은 반환 값으로 재정의 하는 것
> - Overroding : 하나의 클래에 같은 이름, 다른 매개변수, 반환 값은 상관없이 재정의 하는 것

---  

## 5. 생성자
> - 인스턴스를 생성할 때마다 호출되는 인스턴스 초기화 메소드
> - return 값이 없음
> - 클래스 이름과 같아야 함
> - 기본 생성자가 아닌 생성자 메소드를 정의하면 무조건 기본 생성자를 만들어줘야 함

---  

## 6. 가비지 컬렉터 (Garbage Collector)
> - 더 이상 사용하지 않는 객체들을 자동으로 청소(메모리 해제)시켜줌
> - 객체를 생성하면 Heap 내에 Young 영역으로 가서 이곳에서 접근 불가능 상태가 되서 객체가 사라질 때(메모리 해제)를 "Minor GC 가 발생했다" 라고 한고, 여기서 살아남은 객체들이 Old 영역으로 가서 이곳에서 접근 불가능한 상태가 되서 객체가 사라질 때(메모리 해제)를 "Major GC 가 발생했다" 라고 한다.

---  

## 7. Java primitive data types 
> byte, short, int, long, double, float, boolean, char

---  

## 8. 컴파일러와 인터프리터
> - Compiler : 프로그램 단위로 프로그램 전체를 함께 번역하고 수행하기 때문에 번역 시간은 오래 걸리지만 수행 속도는 빠름
> - Interpreter : 한 줄, 한 줄씩 번역해 수행하기 때문에 수행속도는 느리다. 이로 인해 CPU 사용 시간이 낭비된다고 한다.

---  

## 9. 자바 실행과정
> .java 를 byte code(.class)로 변환하여 JVM 으로 실행  
> 즉, .java 를 컴파일 한 후 그 결과로 나온 .class 파일들을 JVM 으로 한 줄, 한 줄씩 읽는다

---  

## 10. JVM 메모리 구조 (Runtime Data Area)
> - Method Area : 인스턴스 생성을 위한 필요 정보(필드, 메소드, 생성자)를 적재한 공간
> - Heap : 객체들이 적재되는 공간. 메소드 지역에서 참조한 값을 바탕으로 새로운 객체를 생성하면 이곳에 적재한다. 또한, 모든 스레드는 하나의 Heap 을 공유한다.
> - Stack : 메소드 프레임들이 스택에 하나씩 쌓임. Last in First out 이다. 또한, 스레드는 자신들만의 고유한 Stack을 가지고 있다.
> - PC Register : 현재 실행되고 있는 부분의 주소를 가지고 있다. 프로그램 카운트는 현재 실행되고 있는 명령이 끝나고 증가된다.
> - Native Method Area : 네이티브 방식의 메소드가 실행될 경우 이곳에 적재된다.

---  

## 11. OSI 7계층 - 물데네전세표응~
> - 물리계층 : 하드웨어의 물리적이고 전자적인 특성을 정의. 디지털 신호를 전기신호로 변환해 전송한다.
> - 데이터 링크 계층 : 물리 계층의 연결 신뢰도 향상. 링크의 활성화, 유지, 비활성화 기능 제공
> - 네트워크 계층 : 패킷 단위로 데이터를 분할. 경로 설정.
> - 전송 계층 : 경로 설정 및 데이터 전송 책임. 세션 계층에 서비스 제공. 노드와 노드 사이 라우팅 지시
> - 세션 계층 : 연결 공유, 전송 조정, 데이터 동기화, 네트워크 오류 검사, 데이터 재전송
> - 표현 계층 : 문자집합 변환. 캡슐화, 압축
> - 응용 계층 : 사용자 프로그램과 관련된 계층. 응용 프로그램을 네트워크와 연결

---  

## 12. TCP / UDP
> - TCP : 연결지향으로, 자체적으로 오류해결. 네트웍 전송 중 뒤바뀐 메세지를 교정해주는 기능있음.  
실시간 처리 시 메세지 순서 잘못되면 다시 요청
> - UDP : 비연결지향, 오류처리나 순서 재조합 기능 없음. 단순히 데이터를 받거나 던지기만 함  
실시간 처리시 패킷 손실 있어도 그냥 처리함

---  

## 13. HTTP / HTTPS
> - HTTP : TCP/IP 를 이용하는 응용 프로토콜. 연결 상태를 유지하지 않는 프로토콜임. 그래서 요청과 응답이 존재하며, 암호화 X, 통신 상태 확인 X -> 변조 가능
> - HTTPS : HTTP 통신을 하는 부분을 SSL or TLS 로 대체. (TCP 와 통신하지 않고 SSL 통신). 하지만 느린데 이 이유는 클라이언트 요청 시, SSL에 필요한 통신 추가와 암호화, 복호화 계산으로 인해 리소스 낭비하기 때문.
> - 추가적으로 웹 관련으로 면접볼거면 SSL, TLS 정도는 알고가자 ㅎㅎ

---  

## 14. Web Application Server (WAS)
> - WAS : 웹 서버와 웹 컨테이너의 결합으로 다양한 기능을 컨테이너에 구현하여 다양한 역할을 수행할 수 있는 서버, 서버 단에서 어플ㄹ케이션을 동작할 수 있도록 지원하는 서버(동적인 컨텐츠 제공)
> - Web Container : JSP, Servlet 구동 환경 제공 (동적 data 처리)
> - Web Server : 요청 받아 Controller 로 전송 / 결과값 받아 클라이언트로 전송 (동적 data 처리)
> - Ex : '개발자' 라고 검색할 시 DB 에서 가져오고 하는 일은 WAS, 검색 후 보여지는 웹 브라우저의 HTML, CSS, JS 등은 웹 서버에서 처리

---  

## 15. 스프링 동작 과정
> - 클라이언트 요청 시(URL) 디스패처 서블릿으로.
> - 디스패처 서블릿에서 Handler Mapping 에 요청 URL 과 매핑되는 컨트롤러 검색
> - 매핑된 컨트롤러로 처리요청 후 Model, View 반환
> - 디스패처 서블릿에서 View Resolver 로 반환받은 view 정보를 넘겨 view 검색
> - View Resolver 에서 view 리턴
> - 디스패처 서블릿에서 View 로 리턴받은 view 와, Model 을 넘겨 Model 에 데이터를 view에 셋팅 후 디스패처 서블릿으로 반환
> - 디스패처 서블릿에서 클라이언트로 반환

---  

## 16. AOP (Aspect Oriented Programming)
> - 기능을 핵심 비지니스 로직과 공통 모듈로 구분하고, 핵심 로직에 영향을 미치지 않고 사이사이에 공통 모듈을 효과적으로 잘 끼워넣도록 하는 방법
> - EX) 보안 인증, 세션, 로깅 같은 요소

---  

## 17. IoC / DI
> - IoC : 작업을 수행하는 쪽에서 객체를 생성하는게 아닌 특별한 object 에 의해 만들어지고 사용된다. 객체의 생성에서부터 생명주기의 관리까지 모든 객체에 대한 제어권이 Ioc 컨테이너에 위임한다. EX) 프레임워크
> - DI : 각 계층 사이, 각 클래스 사이에 필요로 하는 의존관계를 컨테이너가 자동으로 연결 해주는 것
> - DL : Bean 에 접근하기 위해 컨테이너에서 제공하는 API를 이용해 LookUp 하는 것

---  

## 18. API 
> - 기존의 어떤 프로그램을 제어할 수 있도록 만든 인터페이스

---  

## 19. REST
> - URI 와 HTTP 메소드를 이용해 객체화된 서비스에 접근하는 것.
> - 리소스에 접근하여 HTTP 메소드를 이용한 그것을 조작하는 것
> - RESTful API : 리소스 행위 직관적 분리, 메세지는 헤더와 바디를 명확하게 분리, 서버와 클라가 같은 방식으로 요청하도록 해야 함

---  

## 20. equals 와 == 차이
> - equals 는 객체의 값으로 비교를 함 (메소드)
> - == 은 객체의 주소값으로 비교 (연산자)

---  

## 21. String a="" 과 new String("") 의 차이
> -  a = "" 같은 경우 Heap 내의 String constant pool 에 저장시키거나 이미 존재하는 문자열이면 그 저장된 배열의 인덱스 번호를 가리키게 한다. 
> - new String("") 는 Heap 내의 일반적인 객체를 생성한다.
<pre><code>
String a = "a";
String b = "a";
a == b 는 true

String a = new String("a");
String b = new String("a");
a == b 는 false
</code></pre>

---  

## 22. GET, POST
> - GET : 요청하는 데이터가 HTTP Request Message Header 부분의 url 에 담겨 전송. 그래서 데이터 크기에 제한. url 에 노출됨  
서버에서 데이터 가져올 때
> - POST : 요청하는 데이터가 HTTP Request Body 에 함께 전송. GET 보다 데이터 크기 크게 보내기 가능  
서버 값이나 상태 변경할 때

---  

## 23. 프로세스와 스레드 차이
> - 프로세스 : 실행 중인 프로그램 (램에 올라간 프로그램). 메모리에 주소 공간을 갖는다.
> - 스레드 : 프로세스의 실행 단위. 한 프로세스 내에서 동작하는 여러 실행흐름으로, 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. 

---  

## 24. Hash Map 작동 원리
> - Hash Map : key 와 Value 로 이루어진 자료구조. 내부구조는 배열로 되어있음
> - 인덱스를 구하기 위해 해쉬함수를 사용함. 그래서 Hash Code 를 구하면 동일 중복 값이 발생할 수 있는데(해쉬 충돌) 해쉬 충돌을 방지하기 위해 <code>Open Adressing</code> 과 <code>Separate Chaning</code> 이 있다.
> - Open Adressing : 해쉬충돌 발생 시 인접 index 값을 새로 구해서 해쉬충돌 우회
> - Separate Chaning : 동일한 해쉬 값 존재 시 링크드리스트로 관리
> - Java 8 에서는 데이터가 6개 이상이면 Tree 를 사용하고 6개 이하면 링크드리스트를 사용한다.
> - 여기서 2개의 차이를 둔 것은 만약 차이가 1일 때 어떤 한 데이터가 반복되어 삽입 삭제 되는 경우 트리와 링크드리스트를 변경하는데 반복되므로 성능 저하가 발생되므로 2개의 차이를 둠

---  

## 25. 세션과 쿠키
> - Session : 일정 시간동안 같은 사용자(브라우저)로 부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술
> - Cookie : 특정 웹 사이트를 방문했을 때 만들어지는 정보를 담는 파일

여기서 쿠키는 컴퓨터 메모리에 저장하지만, 세션은 웹서버에 저장된다.

HTTP Session 의 동작 순서는 다음과 같다.
1. 클라이언트가 서버로 request 날린다.
2. 서버는 클라이언트가 보낸 request header 에 cookie 를 확인해 session-id 존재하는지 확인
3. 없으면 session-id 생성해 response 헤더에 담아 보낸다

---  

## 26. POJO (Plain Old Java Object)
> 특정한 API(Servlet, EJB 등) 를 상속하거나 구현하지 않고 사용한다는 뜻이다. 그래서 프레임워크 간이나 클라이언트 간 이식성을 높일 수 있다.

예를 들어, Sevlet 을 직접 구현하는 경우에 Servlet 으로 밖에 사용을 못하고 Test 를 하기 위해 Request, Responst 를 mock 으로 구현해야 한다.

- 특정 규약에 종속되지 않는다.
- 특정 환경에 종속되지 않는다.
- 객체지향원리에 충실해야 한다.

그래서 Spring 은 POJO 프레임워크 중 하나이다.

---  

## 27. Thread 란
> 동시에 여러가지 작업을 수행할 수 있게하는 것이다. 또한, 프로레스 내에 존재하는 여러 개의 실행 흐름이다.

- 프로세스 내에는 여러 개의 쓰레드가 존재할 수 있는데, 각각의 쓰레드마다 독립적인 스택을 가지고 있고, 프로세스의 heap, static, code 영역 등을 공유한다.

---

## 28. Context Switching 
- 쓰레드 컨텍스트 스위칭 : OS 에서 하나의 작업을 진행하기 위해 해당 스레드의 Context 를 읽어오고, 다시 다른 쓰레드로 작업을 변경할 때 이전 쓰레디의 Context 를 저장하고 진행할 스레드의 Context 를 읽어오는 작업을 말한다. 즉, 한 스레드에서 다른 스레드로 작업을 넘기는 과정

- 프로세스 컨텍스트 스위칭 : 위와 같다.

여기서 쓰레드가 프로세스보다 컨텍스트 스위칭이 빠른 이유는 쓰레드는 서로 메모리 영역을 공유하기 때문이다.

---

## 29. DeadLock 이란
> 영원히 오지않는 이벤트를 기다리는 것

예를 들어, A라는 프로세스가 B가 가진 자원이 있어야 동작 가능하다. 그런데 B도 A가 가진 자원이 있어야 하기 때문에 서로 작업이 끝나기만을 기다리는 상태

데드락 조건 (한 가지라도 만족하지 않으면 데드락 발생하지 않는다)
 - 상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구
 - 점유대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다
 - 비선점 : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다
 - 순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다

데드락 예방
 - 상호배제 조건의 제거
    - 데드락은 두 개 이상의 프로세스가 공유 불가능한 자원을 사용해서 발생한 것이므로.
 - 점유와 대기 조건의 제거
    - 한 프로세스가 수행되기 전 모든 자원을 할당시키고 나서 점유하지 않을 때에 다른 프로세스가 자원을 요규하도록 하는 방법. 비용 문제가 있다.
 - 비선점 조건의 제거
    - 비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어 준다
 - 환형 대기 조건의 제거
    - 자원 유형에 따라 순서를 매긴다

데드락 회피 방법
 - 은행원 알고리즘 : 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있는지 사전에 검사해 교착 상태를 회피하는 방법.

---

## 30. Spring 을 굳이 사용하는 이유  
DI(Dependency Injection), IoC(Inversion of Control), Test 때문에 사용한다고 생각함. new 로 인스턴스 생성하는 방식은 모듈간 강한 결합을 불러와 변경이나 확장 등에서 자유롭지 못함. 하지만 생성자, setter 등으로 외부에서 생성된 객체의 인스턴스를 사용만 하는 구조로 개발하면 변경이 있을 때 해당하는 부분의 클래스만 변경하면 된다. 이런 구조를 Spring 에서 인터페이스를 만들고 그 구현체를 만드는 패턴으로 개발되기 때문에 모듈 단위의 테스트를 하기에도 쉽다. 

---

## 31. 세마포어와 뮤텍스 
> 세마포어와 뮤텍스는 둘 다 locking 기법이다. 자원에 대해 접근을 제한한다는 기법.

- 뮤텍스 : 한 번에 한 thread 만 돌게하고 나머지는 waiting 하도록 하고, 해당 thread 의 작업이 끝나면 waiting 중이던 쓰레드가 해당 자원을 사용할 수 있도록 한다. (key 는 무조건 1개)
- 세모포어 : 자원에 접근 할 수 있는 허용갯수를 정해준다. (key 는 여러개 가능. key 를 가지고 있어야 접근 가능)

---

## 32. Spring 이란
> Spring 이란 자바 기반의 다양한 어플리케이션을 개발하기 위한 경량의 프레임워크이다. 경량이란 말은 불필요하게 무겁지 않다라는 뜻이다. POJO 기반의 프레임워크이기도 하다.

---

## 33. 프레임워크란
> 프레임워크는 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 클래스들을 제공하는 것. 

쉽게 말하면, 애플리케이션의 틀과 구조를 결정하고 개발자의 코드를 프레임워크가 제어한다.

---

## 34. JDK(Java Development Kit)
> 자바 개발을 위한 도구로, 자바 컴파일러, JVM, 각종 자바 라이브러리 등을 포함하고 있는 필수 도구이다. 참고로 JDK 는 JRE를 포함하고 있다.

---

## 35. ORM(Object-Relational Mapping)
> 객체와 관계형 DB를 매핑해주는 것. SQL 을 직접 작성하느 번거로운 작업을 줄여준다.

장점 : 
    - 객체지향적인 코드로 인해 더 직관적이고 비지니스 로직에 더 집중할 수 있게 도와줌
    - 재사용 및 유지보수의 편리성이 증가
    - DBMS 에 종속성이 들어든다. (자료형 타입, 구현 방법 등)
단점 :
    - 사용하기는 편하지만 설계를 매우 신중하게 해야함
    - 프로젝트가 복잡해질 수록 난이도가 올라감
    - 잘못 구현할 경우 속도 저하가 일어날 수 있음

---

## 36. 직렬화, 역직렬화란
> 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술.
> 역직렬화란 바이트(byte) 형태로 변환된 데이터를 다시 객체로 변환하는 기술이다.

사용 예 : 
    - 서블릿 세션 : 세션을 파일로 저장하거나 세션 클러스터링 등에 사용될 때

---

## 37. Thread Pool, Fork Join Pool
> Thread Pool : 일정 갯수의 쓰레드를 두어, 만약 쓰레드에서 작업해야 할 일이 생기면 대기 상태인 쓰레드가 있는지 보고, 대기 상태인 쓰레드가 있다면 그 쓰레드로 작업해야 할 일을 처리하고, 모두 처리하면 그 쓰레드를 소멸시키는게 아니라 다시 대기 상태로 전환하는 것을 말함.

쓰레드풀을 사용하는 이유는, JVM 의 쓰레드는 OS의 쓰레드 모델을 그대로 가져와서 쓰레드를 생성하고 소멸하는 과정에서 OS 오버헤드가 생기기 때문이다.

> Fork Join Pool : 작업해야 할 일이 생겼을 때, 쓰레드 풀에서 대기 상태인 쓰레드들 중, A라는 쓰레드에 해당 작업을 받아 A 로컬 큐에 작업을 분활하고, 또 B 쓰레드는 A 쓰레드에서 분활했던 A 로컬 큐에서 작업을 가져온다. B의 작업이 많아서 다시 분활하고, C 쓰레드는 B 로컬큐에서 다시 작업을 가져와 이렇게 모든 쓰레드가 골고루 가져가서 작업을 수행하는 것.

---

## 38. 로드 밸런싱
> 하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버가 분산처리하여 서버의 로드율 증가, 부하량, 속도저하 등을 적절히 분산처리하여 해결해주는 서비스.

서비스 방식 
- 네트워크 상단에 로드밸런서가 존재하여 서버로 들어오는 패킷을 실제 서버로 균일하게 트래픽을 부하 분산시킨다.

장점 
- 고가의 서버로 확장하지 않고 저렴한 비용으로 다수의 서버를 증설해 비용절감 가능
- 1대의 서버 장애가 발생하여도 서비스 중단 없이 다른 서버로 적절히 자동으로 분배하여 서비스가 계속 운용 가능하게 할 수 있음
- 추후 서버 확장이 되어도 서비스 중단없이 서버 증설 가능

스케줄링 알고리즘
- 실제 서버에 처리를 분산할 때, 모든 서버로 균등하게 분산하면 스펙이 다른 서버가 존재하는 환경에서는 그 서버에 트래픽이 치우칠 수 있다. 그래서 상황에 맞는 스케줄링 알고리즘을 사용해야 한다.
    - Round-Robin : 모든 서버로 균등하게 처리가 분산됨
    - Weighted Round-Robin : 가중치를 서버에 두어서, 가중치가 큰 서버일 수록 빈번하게 선택되므로 처리능력이 높은 서버는 가중치를 높게 설정하는 것이 좋음
    - Least-Connection : 접속 수가 가장 적은 서버를 선택. 대부분의 경우 해당 알고리즘을 사용해도 충분
    - Weighted Least-Connection : (접속수+1)/가중치 가 최소가 되는 서버를 선택하므로 고성능 서버는 가중치를 크게한다.
    - Shortest Expected Delay : 가장 응답속도가 빠른 서버를 선택한다. 패킷을 날려 응답시간 측정이 아닌, 상태가 ESTABLISHED 인 접속수가 가장 적은 서버를 선택한다.

---

## 39. Long Polling
> 기존의 주기적인 Polling 방식(주기적으로 요청하여 결과를 확인하는 방식) 대신 요청에 대한 응답을 서버 이벤트 발생 시점에 응답하는 방식이다.

Long Polling 은 실시간 메시지 전달이 중요하지만 서버의 상태 변경이 빈번히 발생하지는 않는 서비스에 적합하다.

즉, 서버에 요청을 보내고 서버 이벤트가 발생할 때까지 연결을 유지하고, 이 상태에서 이벤트가 발생하면 응답을 받아서 처리한다.

---

## 40. 객체지향과 절차지향
> 절차지향 : 모든 것들이 순서대로 실행되는 것. 
> 객체지향 : 순서가 아닌 조직에 관점을 맞춘 방식. 실행되는 절차보다는 객체 간의 관계/조직에 초점이 있음

---

## 41. Mybatis, Ibatis
> 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와주는 프레임워크이다. XML 로 SQL 문을 소스 코드로부터 완전 분리.

해당 프레임워크를 사용하는 이유
- 소스 코드에 sql 문이 있어서 재사용성 등이 앉돟아짐.

Mybatis, Ibatis 차이
- Ibatis 는 아파치 프로젝트 였을 때이며, 구글로 넘어가면 Mybatis로 이름을 바꾸고 몇 가지 차이가 생겼다.
    - ibatis 는 jdk 1.4 이상, Mybatis 는 jdk 1.5 이상
    - 패키지 구조 다름.
    - SqlMap.xml 에서 Ibatis 는 "parameterMap", Mybatis 는 "parameterType" 으로 변경
    - Ibatis 는 네임스페이스 속성이 선택이지만, Mybatis 는 필수이다.

---

## 42. 각 DBMS 차이
oracle, mysql, mssql 로 비교를 하겠다.
- mssql 은 윈도우만 지원하며, Oracle 이 제일 많은 os 를 지원한다.
- 지원하는 언어는 mssql < mysql < oracle 순이다.
- 똑같은 기능이어도 function 명이 다르다. (Ex. ISNULL, IFNULL, NVL)

추가로 PostgreSql, Mysql 에 차이를 알아봤다.
- PostGIS의 gist index 의 경우 Mysql 의 spatial index 에 비해 10x 이상의 성능 향상을 가져다 준다고 한다.

잘모르겠다.

---

## 43. 인터셉터, 필터, AOP
Spring 인터셉터와 필터, AOP 의 차이에 대해서 알아보겠다.

이 세가지 모두 요청 중간에 가로채서 처리를 하는 의미이다.

차이점
- 발생하는 시점이 다르다. Filter -> Interceptor -> AOP
- 적용 방식이 다름. Filter : web.xml, Interceptor : servlet-context.xml
- 필터는 디스패처 서블릿보다 앞단에 있고, 인터셉터는 디스패처 서블릿을 거치고 들어온다.

Filter
- 전체적인 Request 에 어떤 처리가 필요할 때
- 인증, 이미지변환, 데이터 압축, 암호화필터 등
- 문자 인코딩 등

Interceptor
- 세션 및 쿠키 체크하는 Http 프로토콜 단위로 처리해야하는 일이 있을 때
- 로그인 세션 체크 등
- insert 또는 update 하는 부분에만 로깅하거나 특정 에러처리 부분만 로깅할 때는 불가

AOP
- 비지니스 단에서 세밀하게 조정할 때
- 로깅, 트랜잭션, 에러처리 등

---

## 44. 정규화
> 관계형 데이터베이스에서 중복을 최소화하기 위해서 데이터를 구조화하는 작업이다.  
> 정규화 과정을 마치면 정규형을 만족하게 되는데, 1정규형, 2정규형, 3정규형 등이 존재한다

제 1정규형
- 원자적 데이터로 구성된 열은 같은 타입의 데이터를 여러 개 가질 수 없음   
 
>1NF를 만족하지 않음

>| 동물idx | 동물이름 |
>| :------ | :------ |
>| 1 | 호랑이 |
>| 2 | 사자 |
>| 3 | 독수리,까치 |

> 1NF 만족
> 
>| 동물idx | 동물이름 |
>| :------ | :------ |
>| 1 | 호랑이 |
>| 2 | 사자 |
>| 3 | 독수리|
>| 4 | 까치 |

제 2정규형 
- 이행적 함수 종속이 있을 때, 그 것을 쪼개는 것을 말한다. 정적인 데이터에서 한 필드가 다른 필드를 정의할 수 있을 때 나눠야 한다.
- 지역idx와 가게idx 을 이용해 매출을 알 수 있지만, 지역특산물은 지역idx 로만으로도 알 수 있음.

> 2NF 만족하지 않음 
>   
> | 지역 idx | 가게 idx | 지역특산물 | 매출 |  
> | :---- | :---- | :-----| :---- |  
> | 1 | 1 | 사과 | 5000 |  
> | 1 | 2 | 사과 | 10000 |  
> | 1 | 3 | 사과 | 2000 |  
> | 2 | 1 | 바나나 | 10000 |  
> | 3 | 1 | 삼겹살 | 100000 |    

> 2NF 만족  
> 
> | 지역 idx | 가게 idx | 매출 | 
> | :---- | :---- | :---- |
> | 1 | 1 | 5000 |  
> | 1 | 2 | 10000 |  
> | 1 | 3 | 2000 |  
> | 2 | 1 | 10000 |  
> | 3 | 1 | 100000 |  
>   
> | 지역 idx | 지역특산물 |  
> | :---- | :----- |  
> | 1 | 사과 |  
> | 2 | 바나나 |  
> | 3 | 삼겹살 |  


제 3정규형
- 기본키에 의존하지 않고 일반 컬럼에 의존하는 컬럼을 제거하는 것을 말한다.
- 지역 idx 가 아니라 지역특산물에 의존하는 특산물선호도가 존재

> 3NF 만족하지 않음  
> 
> | 지역 idx | 지역특산물 | 특산물선호도 |  
> | :---- | :----- | :---- |  
> | 1 | 사과 | 20 |  
> | 2 | 바나나 | 10 |  
> | 3 | 삼겹살 | 1000 |  

> 3NF 만족  
> 
> | 지역 idx | 지역특산물 |  
> | :---- | :----- |  
> | 1 | 사과 |  
> | 2 | 바나나 |  
> | 3 | 삼겹살 |  
  
> | 지역특산물 | 특산물선호도 |  
> | :----- | :---- |  
> | 사과 | 20 |  
> | 바나나 | 10 |  
> | 삼겹살 | 1000 |  

---

## 45. 그래프 자료구조
> 일련의 정점(node, vertex, 꼭짓점) 집합 V와 간선(edge, 변) 집합 E로 구성된 자료구조의 일종이다. 일반적으로 정점엔 데이터, 간선엔 정점과 정잠 사이의 관계 정보가 포함되어 있다.

쉽게 한 마디로 말하면 사물들 간의 순서 또는 관계를 그래프로 표현한 것이라고 생각하면 된다.

```
[V1] ------ e1 ------- [V2]------e3------[V4]
                         |
        [V3] ---- e2---- |
          |
          e4
          |
         [V5]   
```

- 인접행렬 : 2중배열로 사용되며 인접리스트에 비해 쉽다.
```
  j  
i 0 1 0 0 0  
  1 0 1 1 0  
  0 1 0 0 1  
  0 1 0 0 0  
  0 0 1 0 0  
```

- 인접리스트: 자바로 구현한다면 List<>. C++ 이라면 vector<> 로 구현하면 된다.
```
arr.get(0).add(1);

arr.get(1).add(0);
arr.get(1).add(2);
arr.get(1).add(3);

arr.get(2).add(1);
arr.get(2).add(4);

arr.get(3).add(1);

arr.get(4).add(2);

출력값:
1
0 2 3
1 4
1
2

[1] --->  [2]
[2] --->  [1] -> [3] -> [4]
[3] --->  [2] -> [5]
[4] --->  [2]
[5] --->  [3] 
```

---

## 47. DFS 와 BFS 차이
- DFS (깊이 우선 탐색)
DFS 는 말 그대로 깊이를 기준으로 탐색을 하는 알고리즘이다.
```
[V1] ------ e1 ------- [V2]------e3------[V4]  
                        |
[V6]--e5--[V3] ---- e2---- |  
            |  
           e4  
            |  
          [V5]      
```
위와 같은 그래프가 있다고 가정할 시 DFS 알고리즘은 아래와 같이 작동한다.

[V1] -> [V2] -> [V4] 이후에 더 이상 검색을 하지 못하기 때문에 다시 [V2] 로 돌아간다.

V[4] -> V[2] -> [V3] -> [V5] 이후에 더 이상 검색을 하지 못하기 때문에 다시 [V3] 로 돌아간다.

V[5] -> V[3] -> [V6] 끝~

위와 같이 깊이를 우선으로 탐색하는 알고리즘이 DFS(Depth-First Search) 이다.

- (너비 우선 탐색)
BFS 는 말 그대로 너비를 기준으로 탐색하는 알고리즘이다.

```
[V1] ------ e1 ------- [V2]------e3------[V4]
                        |
[V6]--e5--[V3] ---- e2---- |
            |
           e4
            |
          [V5]   
```

위와 같은 그래프가 있다고 가정할 시에 BFS 알고리즘은 아래와 같이 작동한다.
[V1] -> [v2] -> [v4] 와 같이 한 줄을 탐색
[V6] -> [V3] 와 같이 그 다음 한 줄을 탐색
[V5] 로 마지막 한 줄을 탐색

위와 같이 너비를 기준으로 탐색하는 알고리즘이 BFS(Breath First Search)

---

## 48. Interface 와 ㅁbstract 차이
> Interface : 모든 메소드가 추상메소드이며 (Java 8 이상부터 default 키워드를 이용해서 일반 메소드의 구현도 가능) 상속 받는 것이 아닌 implement 키워드를 이용해 구현한다.
> Abstract : 추상 메소드가 하나 이상 포함 된 abstract 클래스이다. (일반 클래스에서도 abstract 메소드 정의 가능) abstract 는 일반 클래스에서 상속 받아 사용한다.

정의는 위와 같다. 하지만 하는 일은 비슷하다.

> abstract 는 그 추상 클래스를 상속받아 기능을 이용하고, 확장시키는데에 목적이 있고, interface 는 그 함수의 구현을 강제함으로써 구현 객체의 같은 동작을 보장 할 수 있다.

---

## 49. ArrayList, LinkedList
List<> 인터페이스를 구현하는 ArrayList, LinkedList 클래스가 있다. 

> ArrayList : 배여러럼 공간을 잡은 리스트 형태. 인덱스로 검색 시 한 번에 검색
> LinkedList : 데이터 공간을 잡는게 아니라 데이터를 add() 로 넣을 때마다 꼬리(주소)를 무는 식으로 저장공간이 잡힌다. 인덱스로 검색 시 처음부터 검색해야 함

ArrayList 는 중간 데이터의 삭제 및 추가 시 한 칸씩 밀거나 당겨야 하기 때문에 추가, 삭제가 많을 경우는 속도가 LinkedList 보다 느리다.
LinkedList 는 중간 데이터의 삭제 및 추가 시 그 연결된 주소만 변경하면 되기 때문에 ArrayList 보다 빠르다.

---

## 50. String, StringBuilder, StringBuffer 차이
> String : 문자열 조작하는 경우 유용하게 사용
> StringBuilder, StringBuffer : 문자열을 합치거나 더할 때 사용

String 으로도 + 연산자를 이용해서도 문자열을 합치거나 더할 수 있다. 하지만 JDK 1.5 버전 전에는 + 연산자의 성능 상 이슈가 많았다. 왜냐하면, 자바 String 은 불변 클래스이기 때문에 변경된 것처럼 보이지만 내부적으로 변경된 문자열을 새롭게 만들기 때문이다. JDK 1.5 이후로 컴파일 단계에서 StringBulder 로 컴파일 되도록 변경이 됐다고는 한다.

StringBuilder 와 StringBuffer 의 차이는 StringBuilder 는 동기화 지원하지 않고, StrinbBuffer는 Synchronized 키워드로 동기화를 지원한다

> 참고로 내가 직접 String += 연산과 StringBuilder 의 append 메소드로 실험했을 때는 StringBuilder 가 훨씬 빨랐다.

---

## 52. 추상화란
> 추상화 : 사전적의미는 특정한 개별 사물과 관련되지 않은 공통된 속성이나 관계 등을 뽑아내는 것  

쉽게 생각해서 List<> 인터페이스를 생각하면 된다.

자바에서는 다음과 같은 코드를 작성할 수 있다.
```
List<T> arrList = new ArrayList<>();
List<t> linkedList = new LinkedList<>();
```

---

## 53. 3-hands-shaking
> 클라이언트와 서버가 통신하기 전에 세 번의 패킷 교환을 통해 확인하는 과정을 말합니다.  

- Client 에서 웹서버로 최초 연결 시도 시 SYN 패킷을 보냄
- Server 에서는 SYN 패킷을 받으면 이에 대한 응답으로 SYN + ACK 패킷을 client 에게 보냄
- Client 는 SYN + ACK 를 받으면 연결을 확인하게 되고 Client 는 SYN 에 대한 응답으로 ACK 패킷을 보낸다.
- Server 는 이 ACK 패킷을 받고 해당 Client ip 에 대한 포트를 ESTABLISHED 상태로 전환한다.
- 끝

> SYN : 연결요청 플래그 (시퀀스 번호를 임의적으로 설정해 보낸다)
> ACK : 응답 플래그 (시퀀스 번호에 TCP 계층에서 길이 또는 데이터 양을 더한 것과 같은 ACK 를 보낸다.)

---

## 54. sql injection, xss
> Sql Injection : 사용자가 서버에 보낸 데이터가 SQL 쿼리로 사용되서 DB 나 시스템에 영향을 주는 공격 기법
> 서버에 공격

방지 방법
- 입력된 값에 특수문자 필터링
- 저장 프로시저 사용(프로시저 내부에서 입력값에 대한 검증이 이루어짐)

> XSS(Cross Site Scripting) : 서버에 보내는 값에 자바스크립트를 보내서 다른 사용자에게 자신이 만든 스크립트를 실행시키게 해서 사용자의 정보를 빼내는 것
> 클라이언트 공격

---

## 55. MVC 패턴
> MVC 패턴 : Model, View, Controller 의 약자로 각 레이러 별로 나눈 것이다.

사용자가 Controller 를 조작하면 Controller 는 model 을 통해 데이터를 가져오고 그 정보를 바탕으로 View 를 제어해 사용자에게 전달한다.

MVC 패턴을 사용하는 이유 : 각 레이어 별로 서로 영향을 받지 않게 만들어 유지보수, 확장성, 유연성이 증가

---

## 56. 프로시저란
> 프로시저 : 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합이다. 보통 DB 서버에 저장해놓는다.

최초 실행 시 최적하된 상태로 컴파일이 되고 DB 캐싱되어 저장되는데, 캐시에 저장되면 컴파일 작업과 최적화를 다시 하지 않아도 되서 여러 번 쓰일 때 성능에 향상이 있다고 한다.

또한, 네트워크 트래픽을 감소시키는데 스토어드 프로시저를 사용하면 수백 개의 SQL 문이 필요한 일도 서버에서 프로시저로 처리하기 때문에 한 번 요청하면 끝이다.

---

## 57. maven 
> 자바용 프로젝트 관리 도구

---

## 58. Servlet 이란
> Servlet : 자바 기반으로 만드는 웹 어플리케이션 프로그래밍 기술이다. 클라이언트 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스 구현 규칙을 지킨 자바 프로그램

쉽게 생각하면 MVC 패턴에서 Controller 라고 생각하면 된다.

서블릿 컨테이너는 위의 서블릿을 관리해주는 것이다. 서블릿의 생명주기를 관리하여 요청에 따른 스레드를 생성한다. (톰캣)

---


59. inner 조인, outer join

---

## 60. Monolithic Architecture, MicroService Architecture
> Monolithic Architecture : 모든 도메인 로직이 한 프로젝트 안에 들어가 있음
> MicroService Architecture : 각 중요한 도메인의 기능을 작게 나누어 독립적으로 실행 가능함. (기능을 너무 쪼개면 복잡도 증가)

---

## 61. Redis 사용이유
> Redis(REmote Dictionary Server) : 인메모리 DB 로 NoSQL & Cache 솔루션이다. Key/value 로 데이터를 저장하며 인메모리 기반의 DB이기 때문에 속도가 빠르다고 한다. (참고로 싱글스레드)

- 리스트, 배열과 같은 데이터를 처리하기 유용
- 캐시 기능 

---

## 62. 트랜잭션
> Transaction : 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위

- 원자성 : 트랜잭션이 DB에 모두 반영되거나 전혀 반영되지 않아야 함
- 일관성 : 트랜잭션의 결과는 항상 일관성 있어야 함 (진행되는 도중 DB 변경되도 처음에 진행하기 위해 참조한 DB로 진행)
- 독립성 : 트랜잭션이 완료될 때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없음
- 지속성 : 트랙잭션이 성공할 경우 결과는 영구적으로 반영되어야 함

---

## 63. jQuery
> jQuery : 엘리먼트들을 효율적으로 제어할 수 있는 다양한 수단을 제공하는 자바스크립트 라이브러리.

---

## 64. DDL DML, DCL
> DML(Data Manipulation Language) : 데이터 조작어 (SELECT, INSERT, UPDATE, DELETE)
> DDL(Data Definition Language) : 데이터 정의어 (Create, Alter, Drop, RENAME 등)
> DCL(Data Control Language) : 데이터 제어어 (Revoke, Grant)

---

65. CVS SVN
66. ajax
67. 아파치 웹서버와 톰캣의 차이, 왜 같이 쓴느지
68. TDD
69. DDD