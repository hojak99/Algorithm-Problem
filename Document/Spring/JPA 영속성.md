# JPA 영속성이란

Jpa `@OneToOne` 어노테이션의 Lazy Loading 이슈에 대해서 알아보다가 영속성에 관한 이야기가 나왔다. 

자세히 잘 모르기 때문에 한 번 알아보도록 한다. 

대부분의 내용은 openjpa.apache.org 에서 인용한 내용들이다.

---

우선, 우리는 `영속성 컨텍스트` 에 대해서 알아야 한다. 이것은 JPA 에 있어서 가장 중요한 용어가 될 수 있다.

JPA `영속성 컨텍스트란 Entity 를 영구 저장하는 환경이라는 뜻`이라고 한다. openjpa 에서는 영속성 컨텍스트(persistence context) 는 persistent identity 에 대해 유니크한 entity instance 가 존재하도록 하는 entity 들에 대한 집합 이라고 한다.

여기서 영속성 컨텍스트는 엔티티 매니저(entity manager))를 통해서 접근할 수 있다. 즉, `엔티티 매니저는 라이프 사이클을 컨트롤하며 데이터 저장소 리소스에 액세스할 수 있다`고 한다.

entity 는 다음과 같은 life cycle 을 가지고 있다.

 - 비영속성(new / transient): 영속성 컨텍스트와 전혀 관계가 없는 상태
 - 영속(managed): 영속성 컨텍스트에 저장된 상태
 - 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
 - 삭제(removed): 삭제된 상태

여기서 비영속성 객체는 그냥 순수한 객체, 즉 POJO 를 생각하면 된다. 

영속 entity 란 entity manager 를 통해 entity 를 영속성 컨텍스트에 저장한 entity 이다.

준영속 entity 는 entity context 가 관리하던 영속 상태의 entity 를 영속성 컨텍스트에서 분리된(관리하지 않는) entity 이다.

삭제는 entity 를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

`영송 상태의 entity 는 identity 값이 반드시 있어야 하며 없으면 예외가 발생한다.`

---

여기서 만약 영속성 컨텍스트가 끝나면, 이전에 관리되었던 entity 들은 영속성 컨텍스트에서 분리가 된다.

분리된 entity 들은 이제 entity manager 가 관리하지 않게되며, 더 이상 데이터 저장소 리소스에 접근할 수 없게 된다.

 - 참고로 분리된 entity 에 대해서는 추가적인 영속 상태를 로드할 수 없다.
 - entity manager 는 분리된 entity 를 `find`나 `query` 에서 반환하지 않는다
 - 대신 entity manager 는 분리된 entity 를 `find` 나 `query` 로 호출했을 때 동일한 identity 를 가진 새로운 영속 entity 를 생성한다.

 ---

그렇다면 영속성 컨텍스트에 entity 를 관리함으로 써 얻는 장점을 무엇일까.

 - 1차 캐시
 - 동일성 보장(싱글톤)
 - 트랜잭션을 지원하는 쓰기 지연
 - 변경 감지
 - 로딩 지연

 - 캐시
 insert 를 하고나서 커밋하지 않아도 select 하면 데이터가 나오는데, 이는 캐시에 저장되서 DB 에 저장되진 않지만 임시적으로 중간에(캐시) 저장된다. 이게 바로 영속성 컨텍스트이다. 트랜잭션을 위해 이 기능을 이용하는데 캐시에는 데이터가 아닌 객체형태로 들어간다.

 - 동일성 보장
 캐시에 들어간 객체를 두 번 가져와서 비교하면 동일하다라고 나오는데 마치 싱글톤으로 다루는 것과 같다고 보면 된다.

 - 쓰기 지연
 캐시를 이용해 여러 쿼리를 한 번에 실행할 수 있다. 예를 들어 어떤 두 데이터를 DB 에 넣는다고 했을 때 `insert` 를 두 번 해줘야 할 것이다. 이 때 JPA 에서는 이 `insert` 를 캐시에 모아놓았다가 한 번의 쿼리를 통해 두 개의 데이터를 DB에 저장한다.

 