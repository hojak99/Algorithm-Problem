# Coding Interview

1. 객체지향 프로그램이란?
> 캡슐화, 다형성, 상속을 이용해 코드 재사용성을 늘리고, 유지보수를 감소시키기 위해 객체들을 연결시켜 프로그래밍 하는 것.
  
2. 캡슐화
> - 데이터(변수) 및 함수(메소드)를 논리적으로 하나로 묶은 것(Class)
> - 데이터데이터 일부를 감춰서 외부와의 접근을 메소드(getter, setter)를 통해서만 가능하도록 하는 것

3. 상속
> - 자식클래스에서 부모클래스의 코드를 재사용하기 위함
> - 연관된 일련의 클래스의 공통된 규약을 정의하고 적용하기 위함

4. 다형성
> - Overriding : 부모클래스를 상속받은 자식클래스에서 부모클래스의 메소드를 같은 이름, 같은 매개변수, 같은 반환 값으로 재정의 하는 것
> - Overroding : 하나의 클래에 같은 이름, 다른 매개변수, 반환 값은 상관없이 재정의 하는 것

5. 생성자
> - 인스턴스를 생성할 때마다 호출되는 인스턴스 초기화 메소드
> - return 값이 없음
> - 클래스 이름과 같아야 함
> - 기본 생성자가 아닌 생성자 메소드를 정의하면 무조건 기본 생성자를 만들어줘야 함

6. 가비지 컬렉터 (Garbage Collector)
> - 더 이상 사용하지 않는 객체들을 자동으로 청소(메모리 해제)시켜줌
> - 객체를 생성하면 Heap 내에 Young 영역으로 가서 이곳에서 접근 불가능 상태가 되서 객체가 사라질 때(메모리 해제)를 "Minor GC 가 발생했다" 라고 한고, 여기서 살아남은 객체들이 Old 영역으로 가서 이곳에서 접근 불가능한 상태가 되서 객체가 사라질 때(메모리 해제)를 "Major GC 가 발생했다" 라고 한다.

7. Java primitive data types 
> byte, short, int, long, double, float, boolean, char

8. 컴파일러와 인터프리터
> - Compiler : 프로그램 단위로 프로그램 전체를 함께 번역하고 수행하기 때문에 번역 시간은 오래 걸리지만 수행 속도는 빠름
> - Interpreter : 한 줄, 한 줄씩 번역해 수행하기 때문에 수행속도는 느리다. 이로 인해 CPU 사용 시간이 낭비된다고 한다.

9. 자바 실행과정
> .java 를 byte code(.class)로 변환하여 JVM 으로 실행  
> 즉, .java 를 컴파일 한 후 그 결과로 나온 .class 파일들을 JVM 으로 한 줄, 한 줄씩 읽는다

10. JVM 메모리 구조 (Runtime Data Area)
> - Method Area : 인스턴스 생성을 위한 필요 정보(필드, 메소드, 생성자)를 적재한 공간
> - Heap : 객체들이 적재되는 공간. 메소드 지역에서 참조한 값을 바탕으로 새로운 객체를 생성하면 이곳에 적재한다. 또한, 모든 스레드는 하나의 Heap 을 공유한다.
> - Stack : 메소드 프레임들이 스택에 하나씩 쌓임. Last in First out 이다. 또한, 스레드는 자신들만의 고유한 Stack을 가지고 있다.
> - PC Register : 현재 실행되고 있는 부분의 주소를 가지고 있다. 프로그램 카운트는 현재 실행되고 있는 명령이 끝나고 증가된다.
> - Native Method Area : 네이티브 방식의 메소드가 실행될 경우 이곳에 적재된다.

11. OSI 7계층 - 물데네전세표응~
> - 물리계층 : 하드웨어의 물리적이고 전자적인 특성을 정의. 디지털 신호를 전기신호로 변환해 전송한다.
> - 데이터 링크 계층 : 물리 계층의 연결 신뢰도 향상. 링크의 활성화, 유지, 비활성화 기능 제공
> - 네트워크 계층 : 패킷 단위로 데이터를 분할. 경로 설정.
> - 전송 계층 : 경로 설정 및 데이터 전송 책임. 세션 계층에 서비스 제공. 노드와 노드 사이 라우팅 지시
> - 세션 계층 : 연결 공유, 전송 조정, 데이터 동기화, 네트워크 오류 검사, 데이터 재전송
> - 표현 계층 : 문자집합 변환. 캡슐화, 압축
> - 응용 계층 : 사용자 프로그램과 관련된 계층. 응용 프로그램을 네트워크와 연결

12. TCP / UDP
> - TCP : 연결지향으로, 자체적으로 오류해결. 네트웍 전송 중 뒤바뀐 메세지를 교정해주는 기능있음.  
실시간 처리 시 메세지 순서 잘못되면 다시 요청
> - UDP : 비연결지향, 오류처리나 순서 재조합 기능 없음. 단순히 데이터를 받거나 던지기만 함  
실시간 처리시 패킷 손실 있어도 그냥 처리함

13. HTTP / HTTPS
> - HTTP : TCP/IP 를 이용하는 응용 프로토콜. 연결 상태를 유지하지 않는 프로토콜임. 그래서 요청과 응답이 존재하며, 암호화 X, 통신 상태 확인 X -> 변조 가능
> - HTTPS : HTTP 통신을 하는 부분을 SSL or TLS 로 대체. (TCP 와 통신하지 않고 SSL 통신). 하지만 느린데 이 이유는 클라이언트 요청 시, SSL에 필요한 통신 추가와 암호화, 복호화 계산으로 인해 리소스 낭비하기 때문.
> - 추가적으로 웹 관련으로 면접볼거면 SSL, TLS 정도는 알고가자 ㅎㅎ

14. Web Application Server (WAS)
> - WAS : 웹 서버와 웹 컨테이너의 결합으로 다양한 기능을 컨테이너에 구현하여 다양한 역할을 수행할 수 있는 서버, 서버 단에서 어플ㄹ케이션을 동작할 수 있도록 지원하는 서버(동적인 컨텐츠 제공)
> - Web Container : JSP, Servlet 구동 환경 제공 (동적 data 처리)
> - Web Server : 요청 받아 Controller 로 전송 / 결과값 받아 클라이언트로 전송 (동적 data 처리)
> - Ex : '개발자' 라고 검색할 시 DB 에서 가져오고 하는 일은 WAS, 검색 후 보여지는 웹 브라우저의 HTML, CSS, JS 등은 웹 서버에서 처리

15. 스프링 동작 과정
> - 클라이언트 요청 시(URL) 디스패처 서블릿으로.
> - 디스패처 서블릿에서 Handler Mapping 에 요청 URL 과 매핑되는 컨트롤러 검색
> - 매핑된 컨트롤러로 처리요청 후 Model, View 반환
> - 디스패처 서블릿에서 View Resolver 로 반환받은 view 정보를 넘겨 view 검색
> - View Resolver 에서 view 리턴
> - 디스패처 서블릿에서 View 로 리턴받은 view 와, Model 을 넘겨 Model 에 데이터를 view에 셋팅 후 디스패처 서블릿으로 반환
> - 디스패처 서블릿에서 클라이언트로 반환

16.
